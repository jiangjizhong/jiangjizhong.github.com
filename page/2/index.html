<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="姜太公的记事本">
<meta property="og:url" content="http://oditszapc.com/page/2/index.html">
<meta property="og:site_name" content="姜太公的记事本">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="姜太公的记事本">
  <link rel="canonical" href="http://oditszapc.com/page/2/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>姜太公的记事本</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">姜太公的记事本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>Categories</a>

  </li>
    </ul>
</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oditszapc.com/2012/12/11/How-to-interpret-complex-C-declarations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Jizhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜太公的记事本">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2012/12/11/How-to-interpret-complex-C-declarations/" class="post-title-link" itemprop="url">(译)如何理解复杂的C/C++声明</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2012-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2012-12-11T00:00:00+08:00">2012-12-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 17:07:43" itemprop="dateModified" datetime="2019-08-03T17:07:43+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/翻译/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>原文 <a href="http://www.codeproject.com/Articles/7042/How-to-interpret-complex-C-C-declarations" target="_blank" rel="noopener">How to interpret complex C/C++ declarations</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>是否曾经遇到过一些复杂的、让你无法理解的C声明？ 比如 <code>int * (* (*fp1) (int) ) [10];</code>。 本文由浅入深的教会你理解C/C++的声明。我们先看一些经常遇到的声明，然后是稍微复杂的const和typedef，接下来攻克函数指针，最后是right-left法则。不过要强调的是：不要写太复杂的代码，这里仅仅是告诉你如何<strong>理解</strong>复杂的声明。</p>
<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><p>我们先从一些简单的例子看看，看看下面这个声明</p>
<pre><code>int n;</code></pre><p>可以理解为：n是一个int。解析是指针变量的声明，是这样的</p>
<pre><code>int *p</code></pre><p>可以理解为：p是一个指向int的指针。</p>
<blockquote>
<p>声明指针的时候，最好把*和变量放在一起，而不是和类型放在一起。比如下面的代码</p>
<p>   int* p,q</p>
<p>看上去像是p和q都是int指针，实际上只有p是，q是int。</p>
</blockquote>
<p>指向指针的指针</p>
<pre><code>char **argv</code></pre><p>原则上，指针的层次是无限，你可以声明指向指针的指针的指针的指针的指针的指针……</p>
<pre><code>int RollNum[30][4];
int (*p)[4]=RollNum;
int *q[5];</code></pre><p>上面的声明中，p是一个指针，指向长度为4的int数组。q是一个长度为5的int指针数组。</p>
<h2 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h2><p>const关键字可以阻止一个变量被修改。声明const的变量的时候要对其初始化，因为之后你就不能修改了。</p>
<pre><code>const int n=5;
int const m=10;</code></pre><p>上面的变量m和n类型相同：都是int常量。const和指针一起出现时就会比较绕，例如下面的声明</p>
<pre><code>const int *p;
int const *q;</code></pre><p>他们分别是什么意思？实际上，p和q都是指向int常量的指针。</p>
<pre><code>int * const r= &amp;n; // n是int类型</code></pre><p>这里，p和q都是指向int常量的指针，意味着你不能修改<em>p的值。r是一个指针常量，意味着声明之后，类似<code>r=&amp;m</code>就是非法的，但是`</em>r`可变。</p>
<p>上面两种声明结合起来，可以声明出指向int常量的指针常量</p>
<pre><code>const int * const p=&amp;n // n has been declared as const int</code></pre><p>解析来的一些声明应该能消除对const的疑惑了。要注意的是，有些声明因为没有赋值，会编译不过（为了清晰，所以省略了）。</p>
<pre><code>char ** p1;                    // 指向char的指针的指针
const char **p2;               // 指向char常量的指针的指针
char * const * p3;             // 指向char的指针常量的指针
const char * const * p4;       // 指向char常量的指针常量的指针
char ** const p5;              // 指向char指针的指针常量
const char ** const p6;        // 指向char常量的指针的指针常量
char * const * const p7;       // 指向char的常量指针的常量指针
const char * const * const p8; // 指向char常量的指针常量的指针常量</code></pre><h2 id="精妙的typedef"><a href="#精妙的typedef" class="headerlink" title="精妙的typedef"></a>精妙的typedef</h2><p>typedef能让你克服*-applies-to-variable-not-type（译注：不知道怎么翻译，好在不影响内容）。如果你这样使用typedef</p>
<pre><code>typedef char * PCHAR;
PCHAR p,q;</code></pre><p>p和q都是char指针，如果没使用typedef，p是指针，q是char，这事违反直觉的。下面是一些使用了typedef的声明和解释</p>
<pre><code>typedef char * a;  // a是char指针
typedef a b();     // b是返回char指针的函数
typedef b *c;      // c是指针，指向返回char指针的函数
typedef c d();     // d是一个返回指向char指针的函数的指针的函数（分开说：d是一个函数，返回一个指针，这个指针指向返回char指针的函数）
typedef d *e;      // e指向一个返回指向char指针的函数的指针的函数的指针
e var[10];         // var是长度为10的指向一个返回指向char指针的函数的指针的函数的指针数组 </code></pre><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>理解声明时，函数指针可能是最让人疑惑的。先来看一个简单的函数指针例子：</p>
<pre><code>int (*p)(char);</code></pre><p>声明p是一个指针，指向参数为char，返回int的函数。指向带两个float参数并且返回一个指向char指针的指针的函数的指针:(是这样声明的：</p>
<pre><code>char ** (*p)(float, float);</code></pre><p>如果要声明一个长度为5的指针数组，指针指向一个函数，这个函数有两个指向char的指针常量并且返回void指针，该怎么声明呢？</p>
<pre><code>void * (*a[5])(char * const, char * const);</code></pre><h2 id="右左法则-right-left-rule-【重要】"><a href="#右左法则-right-left-rule-【重要】" class="headerlink" title="右左法则 (right-left rule) 【重要】"></a>右左法则 (right-left rule) 【重要】</h2><p>有一个能让你理解任何声明的简单规则，是这样的：从声明最里面的括号开始阅读，向右继续，然后向左。当你碰到括号，反向。当括号里的内容读完，跳出当前括号。继续上面的方法直到整个声明都读完。对右左法则的小改动：当第一次阅读声明，应该从标识符开始，而不是最里面的括号。举个例子：</p>
<pre><code>int * (* (*fp1) (int) ) [10];</code></pre><ol>
<li>从变量名开始 ——— fp1</li>
<li>右边只有一个)，所以往左走，找到了 *  ————— is a pointer</li>
<li>跳出括号，往右碰到了(int)  ———- to a function that takes an int as argument</li>
<li>往左，遇到了* —————— and returns a pointer</li>
<li>跳出括号，往右遇到了[10]  ———–  to an array of 10</li>
<li>往左，遇到 *  —————–  pointers to</li>
<li>继续往左，找到int ————- ints</li>
</ol>
<pre><code>int *( *( *arr[5])())();</code></pre><ol>
<li>从变量名开始 ——————— arr</li>
<li>向右，找到了数组 ——————— is an array of 5</li>
<li>向左, 找到了* ———————————– pointers</li>
<li>跳出括号，向右找到了() —— to functions</li>
<li>向左，遇到了* —————————– that return pointers</li>
<li>跳出，向右，找到了() ———————– to functions</li>
<li>向左，找到了* ———————————– that return pointers</li>
<li>继续向左，找到了int —————————– to ints.</li>
</ol>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>Nitron: <a href="http://www.codeproject.com/KB/cpp/pointerprelude.asp" target="_blank" rel="noopener">A Prelude to pointers</a><br>cdecl是一个牛B的解释变量声明的工具，还有很多其他用途. 你可以从<a href="http://www.simtel.net/product.php?url_fb_product_page=41564" target="_blank" rel="noopener">这里</a>下载Windows版。</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>This article, along with any associated source code and files, is licensed under The Code Project Open License (CPOL)</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oditszapc.com/2012/12/08/something-about-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Jizhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜太公的记事本">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2012/12/08/something-about-java/" class="post-title-link" itemprop="url">吐槽Java中一些让人不爽的地方</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2012-12-08 00:00:00" itemprop="dateCreated datePublished" datetime="2012-12-08T00:00:00+08:00">2012-12-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 17:08:04" itemprop="dateModified" datetime="2019-08-03T17:08:04+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="某些API的Checked-Exception"><a href="#某些API的Checked-Exception" class="headerlink" title="某些API的Checked Exception"></a>某些API的Checked Exception</h2><pre><code>try{
    String s = &quot;string&quot;;
    byte[] b = s.getBytes(&quot;UTF-8&quot;);
}catch(UnsupportedEncodingException e){
    //What can i do?
}</code></pre><p>让人不爽的api中，String.getBytes绝对是第一，比如上面的代码，绝对不会出现UnsupportedEncodingException（已经确定只使用UTF8了），但还是不得不try catch一次。就不能把UnsupportedEncodingException改成Unchecked吗？</p>
<pre><code>try{
    URL url = new URL(&quot;http://www.google.com/&quot;);
}catch(MalformedURLException e){
    // :(
}</code></pre><p>和第一段代码一样，又要catch一个永远不会出现的异常。</p>
<h2 id="代码太冗长"><a href="#代码太冗长" class="headerlink" title="代码太冗长"></a>代码太冗长</h2><p>比如构建一个Map并且初始化一些值。</p>
<pre><code>Map m = new HashMap();
m.put(&quot;k1&quot;, &quot;v1&quot;);
m.put(&quot;k2&quot;, &quot;v2&quot;);
...</code></pre><p>为什么就不能提供这样的语法呢：</p>
<pre><code>Map m = {&quot;k1&quot;:&quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;}</code></pre><p>您可能要说了，Map只是一个接口，Java怎么知道用哪个Map的实现呢？这个完全不是问题，Java默认采用HashMap不就行了吗。</p>
<h2 id="函数不是一等公民"><a href="#函数不是一等公民" class="headerlink" title="函数不是一等公民"></a>函数不是一等公民</h2><p>Java里只能定义类，所以很多代码看上去很麻烦，比如Swing里常见的事件处理。</p>
<pre><code>button.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e){
            //Execute when button is pressed
        }</code></pre><p>   });      </p>
<p>如果可以直接传递函数，代码会变得很清晰简单</p>
<pre><code>void buttonAction(ActionEvent e){
    //execute when button is pressed
}

button.addActionListener(buttonAction);</code></pre><p>是不是看上去清晰了很多。同样，编写线程代码会很方便，不用非得实现Runnable接口或者继承Thread</p>
<pre><code>void run(){
    ...
}

Thread t = new Thread(run); //直接把函数作为参数传给线程。</code></pre><p>再举个例子，比如我需要在多处代码里对参数做URL Encode</p>
<pre><code>Map params = ...;
for(Map.Entry e:params.entries()){
    //encode
}</code></pre><p>因为很多地方都要做URL Encode，显然要把上面的代码抽离成一个方法，在Java里，就必须先定义一个类，再把方法放进去，于是就出现了各种XXXUtil方法，里面是一堆的静态方法。</p>
<pre><code>public class UrlUtil{
    public static Map encode(Map params){
        for(Map.Entry e:params.entries()){
            //encode
        }
    }
}</code></pre><p>虽然只是要多定义一个类，但是写起来很不爽，影响写代码的心情。</p>
<p>另外，如果函数是一等公民，在Java中也可以实现函数式编程……</p>
<h2 id="不提供特定系统的API"><a href="#不提供特定系统的API" class="headerlink" title="不提供特定系统的API"></a>不提供特定系统的API</h2><p>Java刚出来的时候，其中一个卖点就是跨平台，宣称”Write once, run anywhere”，意思是Java程序员不用考虑可移植性，只要程序写好了，在哪里都可以运行，甚至同一套程序不需要任何调整就能同时运行在PC上和手持设备上。不过，这实在算不上什么卖点，古老的Perl不也是跨平台的吗，如果可以在手机设备里安装Perl解释器，代码同样可以在手持设备里运行。还有Python、Ruby，哪个不是跨平台的。</p>
<p>Java让人不爽的地方在于，它的跨平台是强制的，没有提供任何平台特有的API，不管你是不是真的需要“跨平台”，你都必须“跨平台”！</p>
<!-- 很难和系统中其他程序交互 -->

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>当然，Java作为一种编译型语言，在IDE的帮助下，代码还是很容易阅读的，所以维护Java老代码比较轻松。另外，Java代码写法比较严格，修改起来也不容易出大问题。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oditszapc.com/2012/12/06/java-classloader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Jizhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜太公的记事本">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2012/12/06/java-classloader/" class="post-title-link" itemprop="url">Java ClassLoader</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2012-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2012-12-06T00:00:00+08:00">2012-12-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 17:03:40" itemprop="dateModified" datetime="2019-08-03T17:03:40+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>Classloader是Java独有的东西，正如其名，是类加载器。本文是对Java ClassLoader的一个简单总结，不会很详细，只说一些要点。</p>
<h2 id="Classloader的层次结构"><a href="#Classloader的层次结构" class="headerlink" title="Classloader的层次结构"></a>Classloader的层次结构</h2><pre><code>BootstrapClassloader &lt;--- ExtensionClassloader &lt;--- AppClassloader &lt;--- CustomClassLoader</code></pre><p>如上，前三个是JVM内置的。BootstrapClassloader加载核心类，就是lib/rt.jar, lib/i18n.jar等，ExtensionClassloader加载扩展内，lib/ext下的类。AppClassloader加载应用的类，就是从main开始的类。</p>
<h2 id="Classloader的双亲委托模型"><a href="#Classloader的双亲委托模型" class="headerlink" title="Classloader的双亲委托模型"></a>Classloader的双亲委托模型</h2><p>Classloader采用双亲委派模型，Classloader<strong>应该</strong>先请求parent Classloader加载类，如果加载不成功再自己加载。这样设计的目的是为了安全性，保证核心类只能由BootstrapClassloader加载，用户不能自己定义java.xxx这样的类。</p>
<h2 id="Classloader的命名空间"><a href="#Classloader的命名空间" class="headerlink" title="Classloader的命名空间"></a>Classloader的命名空间</h2><p>每个classloader为自己加载的类提供namespace，所以类由包名和ClassLoader唯一确定，(test.A, klassloader1)和(test.A, klassloader2)<strong>不是</strong>一个类，强制类型转换会抛出ClassCastException</p>
<pre><code>//当前类的ClassLoader是currentClassLoader，klassLoader的parent是currentClassLoader
MyClassLoader klassLoader = new MyClassLoader(currentClassLoader)

Class c = new MyClassLoader.loadClass(&quot;test.A&quot;);
Object obj = c.newInstance();
A a = (A)obj;</code></pre><p>各位可能觉得这个代码很怪异，当前类已经直接使用了test.A，但是又新建了一个classloader加载test.A。现别管这些，这个例子仅仅是为了说明ClassLoader的namespace。那么这里会不会抛ClassCastException呢？取决于MyClassLoader是怎么实现的。首先，当前类所直接引用的test.A，其ClassLoader是currentClassLoader,所以当前类所<strong>直接引用</strong>的test.A的唯一标识是(test.A, currentClassLoader).如果MyClassLoader是这样的</p>
<pre><code>//MyClassLoader.java

protected void findClass(String name){
  //nothing
}</code></pre><p>MyClassLoader没有覆盖loadClass，自己又没有真正的加载test.A，就会委托parent加载test.A，parent是currentClassLoader，于是变量c实际上就是(test.A, currentClassLoader)，是同一个类，不会出现ClassCastException. 如果MyClassLoader自己加载了test.A，那么变量c就是(test.A, klassLoader)，和当前类直接引用的不是同一个类，会出现ClassCastException。</p>
<h2 id="定义自己的ClassLoader"><a href="#定义自己的ClassLoader" class="headerlink" title="定义自己的ClassLoader"></a>定义自己的ClassLoader</h2><p>ClassLoader必须继承自<code>java.lang.ClassLoader</code>，一般来说，自己实现<code>findClass</code>方法即可，不要覆盖<code>loadClass</code>。看<code>java.lang.ClassLoader</code>的代码可以知道，<code>loadClass</code>方法完成了双亲委托模型，除非确实决定不使用双亲委托模型。可以参考上一段。</p>
<h2 id="JVM让自定义ClassLoader加载哪些类"><a href="#JVM让自定义ClassLoader加载哪些类" class="headerlink" title="JVM让自定义ClassLoader加载哪些类"></a>JVM让自定义ClassLoader加载哪些类</h2><p>假设以下代码，main里new了一个classloader加载A，A里使用了String和B。MyClassLoader自己加载了A而不是委托给parent</p>
<pre><code>//Main.java
MyClassLoader klassLoader = new MyClassLoader();
Class klassA = klassLoader.loadClass(&apos;somepackage.A&apos;);
...

//A.java
String s = &quot;abc&quot;;
B b = new B(s);

//MyClassLoader.java

protected Class findClass(String name){
    //read some byte
//defineClass
}</code></pre><p>运行可以发现，MyClassLoader的loadClass方法被调用了三次，第一次请求加载somepackage.A，第二次请求加载java.lang.String， 第三次请求加载B。可以简单的认为：一旦你自定义的ClassLoader加载了某个类A，JVM将请求你的ClassLoader加载A使用到的所有的类，包括java.lang.*！具体的可以参考JVM连接模型。因此，如果你真的覆盖了loadClass，也要确保调用了parent.loadClass，否则这样一个ClassLoader没有实际用处。</p>
<h2 id="Thread-Context-ClassLoader"><a href="#Thread-Context-ClassLoader" class="headerlink" title="Thread Context ClassLoader"></a>Thread Context ClassLoader</h2><p>很多时候，我们需要用classloader加载某个资源，通常会有三种选择：System ClassLoader, Current ClassLoader, Thread Context ClassLoader.选择正确的ClassLoader就成了头疼的问题。</p>
<ul>
<li><strong>Current ClassLoader</strong>: 当前类的ClassLoader。 getClass().getClassLoader()</li>
<li><strong>System ClassLoader</strong>: 系统ClassLoader，它负责加载classpath下的内容，也就是启动Java时指定的-cp或者-classpath。 getClass().getClassLoader().getSystemClassLoader(). </li>
<li><strong>Thread Context ClassLoader</strong>: Thread.currentThread().getContextClassLoader()</li>
</ul>
<p>比如在我的代码里，我要加载一张图片，让哪个ClassLoader加载呢？起始有个很简单的近似废话的原则：让能加载的ClassLoader加载。</p>
<p>如果能保证要加载的内容在Classpath下，可以使用System ClassLoader。如果只确定资源和当前类在一起，用Current ClassLoader就非常合适。如果知道某个类的ClassLoader可以加载资源，直接用对应类的ClassLoader。</p>
<p>Thread Context ClassLoader不是某个具体的ClassLoader，如果Thread没有设置ClassLoader，默认是parent Thread的ClassLoader，如果所有线程都没设置ClassLoader, 默认是System ClassLoader. 为什么要有Thread Context ClassLoader 呢？有时候，当前类的ClassLoader要动态载入外界提供的资源，但是这个ClassLoader不知道该怎么加载（通过http url？本地路径？压缩文件？），显而易见的方式是告诉当前ClassLoader另外一个ClassLoader，让它通过这个新的ClassLoader加载。Thread Context ClassLoader就是做这个。就以JNDI为例，JNDI的类是由bootstarp ClassLoader从rt.jar中间载入的，但是JNDI具体的核心驱动是由正式的实现提供的，并且通常会处于-cp参数之下（注：也就是默认的System ClassLoader管理），这就要求bootstartp ClassLoader去载入只有SystemClassLoader可见的类，正常的逻辑就没办法处理。怎么办呢？当然是使用Thread Context ClassLoader，把Thread.setContextClassLoader(System ClassLoader)，然后BootstrapClassloader就可以thread.getContextClassLoader().getRes…。 Velocity的资源加载实现也使用了Thread Context ClassLoader，有兴趣的同学可以看看。</p>
<p><em>为什么不采用可以给ClassLoder设置findClass策略的方式呢，比如ClassLoder提供一个方法setFindClassStrategy，然后ClassLoder内部用这个Strategy找到字节数组再defineClass？看上去不错，不过现在Java不支持……</em></p>
<p>综上，如果确定资源在Classpath里，可以用SystemClassLoader，如果自己是ClassLoder，要加载一个不知道该怎么加载的类，又不能委托parent，可以用Thread Context ClassLoder。如果你使用的库要求要使用Thread Context ClassLoder，那么用Thread Context ClassLoder。其他时候，最好用Current ClassLoder.</p>
<h2 id="getResources路径的问题"><a href="#getResources路径的问题" class="headerlink" title="getResources路径的问题"></a>getResources路径的问题</h2><ul>
<li><code>getClass().getResources(path)</code> ，这里的path如果以 / 开头，就是从classpath的根路径开始查找，否则就是相对于当前class开始查找。</li>
<li><code>getClassLoader.getResource()</code> 这里的path不能以/ 开头，从classpath的根路径开始查找。</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oditszapc.com/2012/12/05/mvc-design-pattern-in-web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Jizhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜太公的记事本">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2012/12/05/mvc-design-pattern-in-web/" class="post-title-link" itemprop="url">Web开发中的MVC设计模式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2012-12-05 00:00:00" itemprop="dateCreated datePublished" datetime="2012-12-05T00:00:00+08:00">2012-12-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 17:03:15" itemprop="dateModified" datetime="2019-08-03T17:03:15+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/development/" itemprop="url" rel="index"><span itemprop="name">软件开发</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p>MVC(Model View Control)可谓是为数不多久经考验的好设计模式。很多Java程序员认为MVC就是Web开发中的MVC框架，这显然是不对的。甚至Web框架所使用的，也不是“正统”的MVC模式。MVC最早出现在桌面应用，组件的定义如下：</p>
<ul>
<li><strong>模型</strong>封装了应用的数据、状态和业务逻辑。</li>
<li><strong>视图</strong>负责渲染用户界面，所有和显示相关的都由<strong>视图</strong>负责。<strong>视图</strong>还会关注<strong>模型</strong>的变化，进行界面更新。</li>
<li><strong>控制器</strong>处理用户操作，调用模型提供的方法。</li>
</ul>
<p>在Swing程序里可以见到很多标准的MVC实现，比如JTree和TreeModel分别充当了视图和模型的角色，无所不在的Listener充当了Controller。</p>
<h2 id="Web开发中的MVC"><a href="#Web开发中的MVC" class="headerlink" title="Web开发中的MVC"></a>Web开发中的MVC</h2><p>Web中的MVC和传统MVC最大的不同之处在于，模型变化，没有办法主动通知视图。</p>
<p>对比可以发现，在Web应用中，数据库、领域对象、业务逻辑一起构成“模型”，处理用户请求的Action（不同的框架应该有不同的概念）可以当成“控制器”，jsp页面或者velocity模板等则是“视图”。</p>
<h2 id="MVC的优点"><a href="#MVC的优点" class="headerlink" title="MVC的优点"></a>MVC的优点</h2><p>MVC的核心思想是解偶，各个组件分离，一是每个组件都有明确的职责，便于理解，代码也更干净，易于修改。二是组件的变化不会影响整个应用，比如修改显示风格，不需要关心领域对象和Action，修改业务逻辑也不会动到界面代码。不妨想想JSP这种fast but dirty的方式，需要修改的时候，真让人生不如死。</p>
<p>所以，用MVC框架时要注意，别把业务代码渗透到Action里和页面上，更不要把显示风格相关的东西放到Action和业务代码里。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oditszapc.com/2012/11/26/something-abount-software-maintenance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Jizhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜太公的记事本">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2012/11/26/something-abount-software-maintenance/" class="post-title-link" itemprop="url">软件的可维护性</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2012-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2012-11-26T00:00:00+08:00">2012-11-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 17:03:04" itemprop="dateModified" datetime="2019-08-03T17:03:04+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/development/" itemprop="url" rel="index"><span itemprop="name">软件开发</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>所谓名不正则言不顺，既然要说软件的可维护性，首先就得明确什么是“维护”，什么是“可维护性”。维基百科的解释如下</p>
<blockquote>
<p>Software maintenance in software engineering is the modification of a software product after delivery to correct faults, to improve performance or other attributes.<br>软件维护：软件工程师在软件交付之后对软件做出修改，比如修bug、提升性能等。</p>
</blockquote>
<p>按照这个定义，软件维护就是对现有软件进行修改。无论是修复现有错误也好，增加新功能也好，亦或者是优化某些代码，都是软件维护。但是“维护”的意思还不只如此，我现在“维护XX系统”，不需要对它做任何修改，我要做的是保证XX系统能正常运行，出现问题快速处理，这也是一种维护。不过，本文所有的“维护”都是指对要对代码进行修改的维护。</p>
<p>那么什么是可维护性呢？个人认为可维护性就是软件是否容易维护，如果软件容易维护，它就具有高可维护性，否则维护性很差。</p>
<h2 id="要修改，首先要理解现有的设计和代码"><a href="#要修改，首先要理解现有的设计和代码" class="headerlink" title="要修改，首先要理解现有的设计和代码"></a>要修改，首先要理解现有的设计和代码</h2><p>修改前必须要理解，否则怎么知道该怎么修改呢？理解现有代码是维护最重要的一步。 根据我不多的经验来看，影响可读性的因素主要有过度设计和糟糕的代码风格。</p>
<h3 id="过度设计"><a href="#过度设计" class="headerlink" title="过度设计"></a>过度设计</h3><p>首先是过度设计，有些人做设计的时候总喜欢说：这个以后<strong>可能</strong>会需要，于是把一个本来简单的功能做的复杂无比，开发测试调试花费了大量的时间，他自己觉得很有成就感，但是害苦了后来人。我刚开始工作的时候，接手维护公司的论坛，这个论坛当初是几个牛人开发的，到处充斥着高端的设计思想，随处可见各种模式，还有一个非常NB也巨复杂的权限管理模块，比网络上能搜索到的那些权限管理方案厉害多了，可惜的是直到论坛下线这个权限管理模块的强大也没能完全体现出来，一直都只使用了其中一小部分功能。当时我用了好几天的时间也没能把权限模块搞清楚，更别提整个论坛了。</p>
<p>作为程序员，希望写出强大的，让人一看就肃然起敬的代码，这个可以理解。不过理解不等于赞同，我们必须克制内心的欲望，牢记：KISS (Keep It Simple, Stupid!)。有些人可能说，我把功能设计的很强大并不是为了体现自己厉害，而是将来的确会有这样的需求。嗯，设计的时候考虑将来可能的需求是一件好事，但是不能不加区分的把所有的“可能”需求都做完，只有能明确预见的需求，才是可以提前做的，不确定的，可以考虑下，但不用做，也不应该做，谁知道明天会发生什么。</p>
<h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><p>说到可维护性代码，很多人第一反应就是代码风格，比如变量命名、缩进、抽离子过程、合理的注释、一个函数只做一件事等等。代码风格对于可读性具有至关重要的作用。本文不是详细说明代码风格的，大家可以取Google下，或者读《代码大全》，很好的一本书。</p>
<h2 id="开始修改"><a href="#开始修改" class="headerlink" title="开始修改"></a>开始修改</h2><p>理解了代码，也明确了需求，接下来要考虑怎么改动现有的代码。下面说下修改过程中会遇到的让人头疼的问题，由于例子不好找，就不举例子了。</p>
<ul>
<li>高度耦合的模块</li>
<li>要修改多处重复的代码</li>
<li>一个常见的需求，要修改多处代码（非重复，设计问题，比如加一种类型的操作要修改十几处代码）</li>
<li>完全没有单元测试，集成测试也不容易做，甚至想把系统运行起来都不容易（常见于年久失修的大系统）。</li>
<li>待补充……</li>
</ul>
<h2 id="维护性和心情"><a href="#维护性和心情" class="headerlink" title="维护性和心情"></a>维护性和心情</h2><p>根据经验，代码的可维护性严重影响修改代码时的心情。好代码（容易理解，容易修改的代码），不仅节省理解和决定如何修改所用的时间，减少可能引入的bug，还能使维护人心情愉悦，工作的效率提高。糟糕的代码刚好相反。</p>
<p>另外，如果代码问题很多，维护人员会变得非常烦躁，甚至默念“这代码是哪个SB写的”。问题越多，心情越差，极端情况下，维护人员甚至不愿意完整的阅读代码，很容易引入新Bug。</p>
<h2 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h2><p>很多人都听说过<a href="http://zh.wikipedia.org/zh-cn/%E7%A0%B4%E7%AA%97%E6%95%88%E5%BA%94" target="_blank" rel="noopener">破窗理论</a></p>
<blockquote>
<p> 以一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。又或想像一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。因此破窗理论强调着力打击罪行，以“零容忍”的态度面对罪案。</p>
</blockquote>
<p>破窗理论用在代码维护上也很合适，正如“维护性和心情”一段所说，对于好的代码，维护人员倾向于保持代码良好的可维护性，会更谨慎的进行修改。对于烂代码，在勉强理解的基础上毫无规划的修改，只为了加上本次的需求，导致代码变得更烂。</p>
<p>当然，即使开始良好的代码，随着时间的演变也会逐渐变坏，可能是某个不称职的程序员对其做了修改，导致可维护性变差，也可能是最初的设计和后来的需求不匹配，导致维护性变差。可行的措施，一是要加强代码Review，阻止烂代码（个人认为，Review的标准至少是：Review人员自己能很容易理解新的修改），二是经常进行小的重构，防微杜渐。</p>
<p>未完待续……</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oditszapc.com/2012/11/20/character-encode-and-decode-in-python2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Jizhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜太公的记事本">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2012/11/20/character-encode-and-decode-in-python2/" class="post-title-link" itemprop="url">Python2中字符编码和解码</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2012-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2012-11-20T00:00:00+08:00">2012-11-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 17:02:46" itemprop="dateModified" datetime="2019-08-03T17:02:46+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/language/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="字符和字符集"><a href="#字符和字符集" class="headerlink" title="字符和字符集"></a>字符和字符集</h2><p>所谓字符，就是文字和符号的总称，比如汉字，26个字母，各种运算符号。字符集一般是指特定类型的字符的集合，比如简体汉字就是一个字符集，它表示所有的简体汉字，繁体汉字也是一个字符集，它表示所有的繁体汉字，中文是一个更大的字符集，包括甲骨文、简体汉字、繁体汉字、各种标点符号等等。</p>
<p>字符和字符集在人类开始用符号纪事的时候就算是存在了。只不过没有特别强调出来而已。为什么现在要特别强调呢？这个问题文的好！</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>计算机只能处理0和1，宽松点说，只能处理二进制数据，无论实在内存中、磁盘上亦或是网线里，存在的只有一大串01，怎么用01表示字符呢？很明显：答案就是字符编码，给每个字符一个唯一数字编码，这样就可以用数字表示字符了。</p>
<p>要给所有的字符编码，首先要知道有哪些字符，如果连有哪些字符都不知道，就完全没法编码，你能对娜美克星的字符进行编码吗？所以，要定编码，首先要把字符集定下来。所有的编码中，名气最大的当属ASCII，定义ASCII的大牛们定义的字符集是大小写英文字母、数字、标点和一些控制字符，共128个（包括\0）。我们常用的中文字符编码有GB2112和GBK，最初定义了GB2312编码，它对应的字符集比较小，很多汉字都不在里面，后来定义了GBK编码，收录了更多的汉字。</p>
<p>确定了字符集之后才能对其中的每个字符分配一个唯一的数字号码，就是这个字符的编码。</p>
<p>假设我现在要定义一个自己的字符编码：GFW （向伟大的GFW致敬）。首先要明确字符集：[敏,感,词,*]，一共四个字符。然后给每个字符分配一个号码。</p>
<pre><code>0 敏
1 感
2 词
3 *</code></pre><p>在GFW这个字符编码中，感的编码是1，*的编码是3.</p>
<h2 id="字符编码的计算机内部表示"><a href="#字符编码的计算机内部表示" class="headerlink" title="字符编码的计算机内部表示"></a>字符编码的计算机内部表示</h2><p>在指定编码方式的情况下，所有的字符都可以用数字表示，计算机就可以存储这些数字，再根据使用的编码就可以对应的实际的字符。</p>
<p>现在的计算机都是以字节为单位处理数据，一个字节表示的最大的数字是255，所以如果编码大于255，一个字节就放不下了，必须用两个以上的字节才行，这就是多字节编码。比如GBK编码，里面有几万个汉字和符号，它就用了两个字节存储一个字符。</p>
<p>对于一个字符，它的内部表示就是一个字节数组，ASCII编码的’A’，字节数组是<code>[0x41]</code>，GBK编码的’敏’，字节数组是<code>[0xC3, 0xF4]</code>，UTF-8编码的’敏’，字节数组是<code>[0xE6, 0x95, 0x8F]</code>，GFW编码的’敏’,字节数组是<code>[0x0]</code>。</p>
<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>一种编码方式，Google下。</p>
<h2 id="为什么出现乱码"><a href="#为什么出现乱码" class="headerlink" title="为什么出现乱码"></a>为什么出现乱码</h2><p>出现乱码的本质原因，就是编码和解码用的不是同一种编码方式。比如’敏’，如果我用GBK的方式编码，得到字节数组 <code>[0xC3, 0xF4]</code>，再用UTF-8解码，得到的就是乱码。</p>
<p>所以，Decode的时候必须要知道编码是什么。</p>
<p>还有另外一种乱码的情况，从一种编码转换到另外一种编码的时候，如果存在目标编码不支持的字符，也会出现乱码。比如Unicode到ISO8859-1。</p>
<h2 id="Python的编码解码"><a href="#Python的编码解码" class="headerlink" title="Python的编码解码"></a>Python的编码解码</h2><p>Python2.x 中，没有字节的概念(Python3中出新了bytes)，只有两种字符串：str 和 unicode 。默认定义的字符串都是str类型，定义字符串时候加u就成了unicode类型。</p>
<pre><code>&gt;&gt;&gt; t = &apos;你好&apos;
&gt;&gt;&gt; t
&apos;\xc4\xe3\xba\xc3&apos;
&gt;&gt;&gt; t[0]
&apos;\xc4&apos;
&gt;&gt;&gt; print t[0]
                    # nothing, Because \xc4 is not a printable character
&gt;&gt;&gt; t = u&apos;你好&apos;
&gt;&gt;&gt; t
u&apos;\u4f60\u597d&apos;
&gt;&gt;&gt; t[0]
u&apos;\u4f60&apos;
&gt;&gt;&gt; print t[0]
你
&gt;&gt;&gt;</code></pre><p>本质上，str是输入字符串本地编码后字节数组，比如上面的代码，因为我用的Windows + 交互Idle，输入的汉字是GBK编码的，<code>&#39;\xc4\xe3\xba\xc3&#39;</code>就是’你好’的GBK编码。</p>
<p>Python提供了encode()和decode()这两个方法供我们进行编码转换。Python内部的字符串用Unicode表示，可以用encode把Unicode字符转成指定编码的字节数组(str)，用decode把字节数组(str)转成Unicode字符串。</p>
<pre><code>&gt;&gt;&gt; &apos;你好&apos;.decode(&apos;gbk&apos;)
u&apos;\u4f60\u597d&apos;
&gt;&gt;&gt;

&gt;&gt;&gt; u&apos;你好&apos;.encode(&apos;gbk&apos;)
&apos;\xc4\xe3\xba\xc3&apos;
&gt;&gt;&gt;</code></pre><p>要记住的是，str是一个不带有编码信息的字节数组，Unicode才是真正的字符串。</p>
<p>代码文件中的字符串默认是和代码文件本身的编码一致。例如下面的文件test.py，编码为gbk</p>
<pre><code>#-*-coding:gbk-*-
t = &apos;你好&apos;
x = u&apos;你好&apos;</code></pre><p>那么t的编码是gbk，而x的编码是Unicode，x的编码与文件编码无关。</p>
<p>下面的例子展示从Unicode字符encode成其他字符编码的字节数组，如果存在目标字符集不支持的字符，字符变成文号。</p>
<pre><code>&gt;&gt;&gt; u&apos;你好&apos;.encode(&apos;ISO8859-1&apos;, errors=&apos;replace&apos;)
&apos;??&apos;</code></pre><p>这是调用encode需要注意的，而且这个操作不可逆，真正的变成了问号。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oditszapc.com/2012/11/20/java-garbarge-collector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Jizhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜太公的记事本">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2012/11/20/java-garbarge-collector/" class="post-title-link" itemprop="url">Java Garbage Collector</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2012-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2012-11-20T00:00:00+08:00">2012-11-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 17:02:14" itemprop="dateModified" datetime="2019-08-03T17:02:14+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/language/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>对于Java垃圾收集的一个总结。</p>
<h2 id="垃圾收集（GC）"><a href="#垃圾收集（GC）" class="headerlink" title="垃圾收集（GC）"></a>垃圾收集（GC）</h2><p>用C/C++写代码的人都知道，管理内存是一件苦难而且痛苦的事情，一不小心就出现内存泄漏。Java程序员就幸福多了，从来不用怎么关心怎么回收内存，随心所欲的new对象，虚拟机会帮擦屁股的。提起垃圾收集，很多人就会很自然的会把这个概念和Java关联在一起，实际上垃圾收集早在Java出现之前就已经有了，最要在Lisp中出现，只不过Java名气太大（或者是因为Java程序员太多？）。</p>
<p>那么到底什么是GC呢？<a href="http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="noopener">维基百科</a>的解释如下</p>
<blockquote>
<p>In computer science, garbage collection (GC) is a form of automatic memory management. The garbage collector, or just collector, attempts to reclaim garbage, or memory occupied by objects that are no longer in use by the program.</p>
</blockquote>
<p>简单点说就是，GC是一种自动内存管理的方式，收集器能把不再使用的内存回收。好了，定义就到这里，相信大家本来就有一些概念，没必要深入探讨了。</p>
<p>如果我们要自己实现一个收集器，必然要解决如下两个问题</p>
<ul>
<li><p>哪些内存需要回收  </p>
<p>如果连哪些内存（对象）要回收都不知道还说个屁啊！这个必须要知道。</p>
</li>
<li><p>怎么回收  </p>
<p>知道了哪些内存块可以回收，接下来就怎么回收的问题了。</p>
</li>
</ul>
<p>基本上所有的垃圾收集器都是围绕着这两个问题做各种权衡取舍。</p>
<h2 id="哪些内存可以回收"><a href="#哪些内存可以回收" class="headerlink" title="哪些内存可以回收"></a>哪些内存可以回收</h2><ul>
<li><p>引用计数  </p>
<p>  这种方法是给每个对象增加一个“引用数”属性，当有新的引用指向该对象时，引用数加一，不再引用时，引用数减一。引用数量为零时，对象就可以被回收了。</p>
<p>  引用计数法的主要优点是简单。另外，一旦对象不被引用就可以立即回收，不用特地暂定整个应用来寻找可回收内存，后面提到的Tracing方法就是专门暂停整个应用。</p>
<p>  引用计数法一个很重要的缺点是不能处理循环引用。</p>
</li>
<li><p>Tracing  </p>
<p>  Tracing是从一些存活的对象开始，顺着这些对象的引用开始走，所有遇到的对象都认为是存活的，找完了，剩下的对象都是可回收的。(软引用、弱引用后面再说)。</p>
<p>  和引用计数相比，Tracing的缺点是复杂点，需要暂停整个应用（停止整个应用，然后找到所有存活的对象，再回收已经死亡的对象），需要额外的内存开销。优点是能处理循环引用。</p>
<p>  Java所有的收集器都是才用Tracing算法。Tracing开始的对象称为GC ROOT，包括</p>
<ul>
<li><strong>Class</strong> 系统类加载器加载的类，这些类不能卸载。要注意的是，用户自定义的ClassLoader加载的类不是GC Root.</li>
<li><strong>Thread</strong> 活动的线程</li>
<li><strong>Stack Local</strong> 局部变量、方法的参数</li>
<li><strong>JNI Local</strong> JNI方法的局部变量</li>
<li><strong>JNI Global</strong> JNI全局引用</li>
<li><strong>Monitor Used</strong> 作为锁使用的对象，比如synchronized(obj)，obj就成了GC Root.</li>
</ul>
</li>
</ul>
<h2 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h2><p>这个问题看上去似乎很简单：把对象占用的空间直接标记为可用不就可以了？的确，这是一个办法，不过直接清理会导致内存碎片，最后可能出现虽然还有很大可用空间，但是每个可用空间都很小，大对象分配失败。于是有人提出了另外一个办法：把内存分成同样大小的两部分，任何时候，只使用其中一块，满了之后，把存活的对象Copy到另一块，原来的一块全部清空，这个办法解决了碎片问题，而且效率也不错，但是太浪费内存了，8G的内存只能利用4G，太奢侈。</p>
<p>再后来，就出现了分代垃圾收集。</p>
<h2 id="分代垃圾收集"><a href="#分代垃圾收集" class="headerlink" title="分代垃圾收集"></a>分代垃圾收集</h2><p>分代垃圾收集基于这样的假设：</p>
<ul>
<li>大部分对象的存活时间都很短</li>
<li>很少有老对象到新对象的引用</li>
</ul>
<p>如果这两个假设成立（从现实世界看，这两个假设绝大对数时候都是成立的），GC的时候如果对整个内存堆就显得很浪费。分代垃圾收集把内存堆分成年轻代和年老代，按照对象的年龄把对象放在合适的内存区域。</p>
<img src="/images/generation.gif" width="75%">

<p>年轻代包括eden区和两个survior区，通常，对象在eden区分配，其中一个survior区是空的。Young GC的时候，eden区和使用中的survior里存活的对象被Copy到空的survior，两个survior对调角色。下次GC重复这一过程，所有Copy的对象年龄加一，到一定年龄的时候就进入年老代。</p>
<h2 id="每个代多大合适"><a href="#每个代多大合适" class="headerlink" title="每个代多大合适"></a>每个代多大合适</h2><p>可惜，没有确切的指标说明每个代多大最好，只能根据经验值和实际表现做一些调节。</p>
<ul>
<li>如果年轻代太小，YGC频繁，一些本来存在时间不算长的对象也会进入年老代，进而导致不必要的FGC</li>
<li>如果年轻代太大，年老代就必然变小（内存大小是固定的），FGC频繁，另外YGC也会变慢。</li>
<li>如果Survivor过小， 对象直接从年轻代进入年老代，增加导致不必要的FGC。</li>
<li>Survivor过大会造成浪费</li>
</ul>
<p>一般来说，年轻代占整个堆的1/3到1/4比较合适。但是如果想得到更精确的值，必须对应用中对象的生命周期有清晰的认识，要知道大部分对象能存活多长时间，有多少“永生不死”对象。</p>
<h2 id="JVM中的收集器"><a href="#JVM中的收集器" class="headerlink" title="JVM中的收集器"></a>JVM中的收集器</h2><p>JVM自带了不少垃圾收集器，要注意的是，年轻代和年老代使用的收集器不一样，需要分别指定年轻代和年老代的收集器，而且不是所有的年轻代和年老代收集器可以搭配使用。</p>
<img src="/images/collectors.jpg" width="75%">  

<p>上图中，黄色区域表示年轻代收集器，灰色区域表示可用的年老代收集器，也是三个。连线表示可以搭配使用。可以看出，最多有六种组合。</p>
<ul>
<li><strong>Serial</strong><br>年轻代收集器，单线程，一般只用于开发环境。但是，如果服务器只有一个处理器，就应该使用Serial+Serial Old，使用CMS或者Prallel反而不好。毕竟多线程管理也增加开销。</li>
<li><strong>ParNew</strong><br>年轻代收集器，多线程。要注意和下面的Parallel Scavenge的区别在于，ParNew可以和CMS一起工作</li>
<li><strong>Parallel Scavenge</strong><br>年轻代收集器，多线程，可以和Serial Old或者Parallel Old一起工作，不能和CMS一起。</li>
<li><strong>Serial Old</strong><br>年老代收集器，单线程，一般只用于开发环境。</li>
<li><strong>Parallel Old</strong><br>年老代收集器，多线程，运行的时候暂停整个虚拟机。吞吐率比较好，暂停时间长，适合后台之类的对响应时间要求不严格的应用。</li>
<li><strong>CMS</strong><br>Concurrent Mark Sweep，并发，不是并行。具有比较短的暂停时间，吞吐率不如Parallel Old，适合对响应时间要求严格的应用。</li>
</ul>
<p>设置JVM参数的时候，要搞清楚默认的年轻代或年老代的收集器。</p>
<h2 id="选择收集器组合要考虑的因素"><a href="#选择收集器组合要考虑的因素" class="headerlink" title="选择收集器组合要考虑的因素"></a>选择收集器组合要考虑的因素</h2><ul>
<li><strong>Stop-the-wold</strong><br>正如前面所说，Tracing算法的收集器运行时需要暂停整个虚拟机，只有垃圾收集线程运行。选择收集器时，要考虑能否忍受长时间的暂停，如果对响应时间要求比较严格，就要选择暂停时间短的收集器。</li>
<li><strong>吞吐率</strong><br>在这里，吞吐率表示垃圾收集器运行的时间和应用本身运行的时间的比例，当然是越小越好。</li>
<li><strong>内存碎片</strong><br>使用CMS，要考虑是否开启碎片整理</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oditszapc.com/2012/02/03/simple-method-to-test-bandwidth-between-2-machine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jiang Jizhong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜太公的记事本">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2012/02/03/simple-method-to-test-bandwidth-between-2-machine/" class="post-title-link" itemprop="url">测量两台机器间带宽的简单方法</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2012-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2012-02-03T00:00:00+08:00">2012-02-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-08-03 17:00:06" itemprop="dateModified" datetime="2019-08-03T17:00:06+08:00">2019-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>当然能找到各种软件，不过太麻烦了，有没有现成的工具可以直接使用呢？当然有！那就是……nc，一台机器启动nc监听端口，另一台机器启动nc一直发送数据，一段时间后停止，再计算带宽就行了。当前，这里假设nc把带宽占满了，机器负载不大的时候一般没问题。</p>
<p>机器A，启动nc监听端口</p>
<pre><code>nc -l -n 1234|wc -c</code></pre><p>wc -c不能省略，否则没法知道一共收到多少字节。</p>
<p>机器B，启动nc一直发送数据。</p>
<pre><code>time yes | nc -n A_IP 1234 </code></pre><p>一段时间后，在机器B上按下Ctrl+C，用A机器上输出的数字和B机器上输出的时间算出带宽就行了。比如我这里，A上输出 <code>30496256</code>，B上输出 </p>
<pre><code>real    0m1.080s
user    0m0.804s
sys     0m0.699s</code></pre><p>带宽是 30496256 / 1.080 bps </p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiang Jizhong</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/zjZSTU" title="Github &rarr; https://github.com/zjZSTU" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>Github</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://blog.csdn.net/u012005313" title="CSDN &rarr; https://blog.csdn.net/u012005313" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i>CSDN</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:zjzstu@gmail.com" title="Email &rarr; mailto:zjzstu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>Email</a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Jizhong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>

  
  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



  

  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  


































</body>
</html>
